# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a comprehensive Shopify automation system that includes multiple specialized modules:

1. **Dynamic Collection Manager**: Automates Shopify collection management based on Airtable sales data with dynamic job configurations
2. **Inventory Sync**: Synchronizes product variant inventory quantities to metafields with change detection
3. **Customer Marketing Sync**: Synchronizes customer marketing subscription preferences to metafields

Each module follows a consistent architecture with scheduling capabilities, change detection, and comprehensive logging.

## Core Commands

### Environment Setup
```bash
# Create and activate virtual environment
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt
```

### Development and Testing
```bash
# Run main CLI launcher (recommended)
python main.py

# Run dynamic collection management directly
python scripts/dynamic_collections/main.py --mode manual         # One-time sync
python scripts/dynamic_collections/main.py --mode scheduled      # Continuous mode (every 15 days)
python scripts/dynamic_collections/main.py --dry-run             # Analysis only

# Run inventory sync directly
python scripts/inventory_sync/main.py --mode manual         # One-time sync
python scripts/inventory_sync/main.py --mode scheduled      # Continuous mode (every 2 hours)
python scripts/inventory_sync/main.py --dry-run             # Analysis only

# Run customer marketing sync directly
python scripts/customer_marketing_sync/main.py --mode manual         # One-time sync
python scripts/customer_marketing_sync/main.py --mode scheduled      # Continuous mode (every 6 hours)
python scripts/customer_marketing_sync/main.py --dry-run             # Analysis only

# Legacy test scripts (if they exist)
python test_dynamic_collections.py
python test_airtable.py
python check_shopify_ids.py
```

### Virtual Environment Management
```bash
# Activate environment
source venv/bin/activate

# Deactivate environment
deactivate
```

## Architecture

The system follows a modular, extensible architecture supporting multiple job types and collections:

### Project Structure
```
newcop-backend-jobs/
‚îú‚îÄ‚îÄ main.py                           # Main CLI launcher
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ CLAUDE.md
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ dynamic_collections/          # Dynamic collection functionality
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                   # Dynamic collections orchestrator
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ job_executor.py           # Job executors and factory
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py                 # Pydantic models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_filter.py         # Product filtering logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scheduler.py              # Scheduling utilities
‚îÇ   ‚îú‚îÄ‚îÄ inventory_sync/               # Inventory synchronization functionality
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                   # Inventory sync orchestrator with scheduler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ inventory_manager.py      # Core sync logic with concurrency
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py                 # Data models for inventory tracking
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ storage.py                # Local JSON cache management
‚îÇ   ‚îú‚îÄ‚îÄ customer_marketing_sync/      # Customer marketing synchronization functionality
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                   # Customer marketing sync orchestrator with scheduler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer_manager.py       # Core sync logic with concurrency and retry
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py                 # Data models for customer marketing tracking
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ storage.py                # Local JSON cache management
‚îÇ   ‚îî‚îÄ‚îÄ [future_scripts]/             # Additional script modules
‚îú‚îÄ‚îÄ shared/                           # Shared utilities
‚îÇ   ‚îú‚îÄ‚îÄ airtable_client.py           # Airtable API client
‚îÇ   ‚îú‚îÄ‚îÄ shopify_client.py            # Shopify API client (extended with variant and customer methods)
‚îÇ   ‚îî‚îÄ‚îÄ utils.py                     # Common utilities
‚îú‚îÄ‚îÄ data/                             # Data storage
‚îÇ   ‚îú‚îÄ‚îÄ inventory_cache.json         # Local inventory state cache
‚îÇ   ‚îî‚îÄ‚îÄ customer_marketing_cache.json # Local customer marketing state cache
‚îî‚îÄ‚îÄ logs/
    ‚îú‚îÄ‚îÄ dynamic_collection.log       # Dynamic collections logs
    ‚îú‚îÄ‚îÄ inventory_sync.log            # Inventory sync logs
    ‚îî‚îÄ‚îÄ customer_marketing_sync.log   # Customer marketing sync logs
```

### Core Components

#### Dynamic Collections
- **Main CLI Launcher** (`main.py`): Centralized entry point with menu system
- **DynamicCollectionManager** (`scripts/dynamic_collections/main.py`): Orchestrates discovery and execution of multiple collection jobs
- **JobExecutorFactory** (`scripts/dynamic_collections/job_executor.py`): Creates appropriate job executors based on job type
- **JobExecutor Classes** (`scripts/dynamic_collections/job_executor.py`): Handle specific job type implementations
- **ProductFilter** (`scripts/dynamic_collections/product_filter.py`): Applies business logic for product qualification
- **Data Models** (`scripts/dynamic_collections/models.py`): Pydantic models for configuration validation and type safety

#### Inventory Synchronization
- **InventorySyncOrchestrator** (`scripts/inventory_sync/main.py`): Main orchestrator with APScheduler for 2-hour intervals
- **InventoryManager** (`scripts/inventory_sync/inventory_manager.py`): Core sync logic with concurrent variant updates
- **InventoryStorage** (`scripts/inventory_sync/storage.py`): Local JSON cache management with change detection
- **Inventory Models** (`scripts/inventory_sync/models.py`): Data models for inventory tracking and sync results

#### Customer Marketing Synchronization
- **CustomerMarketingSyncOrchestrator** (`scripts/customer_marketing_sync/main.py`): Main orchestrator with APScheduler for 6-hour intervals
- **CustomerManager** (`scripts/customer_marketing_sync/customer_manager.py`): Core sync logic with concurrent customer updates
- **CustomerMarketingStorage** (`scripts/customer_marketing_sync/storage.py`): Local JSON cache management with change detection
- **Marketing Models** (`scripts/customer_marketing_sync/models.py`): Data models for customer marketing tracking and sync results

#### Shared Components
- **ShopifyClient** (`shared/shopify_client.py`): Manages Shopify API interactions, collections, metafields, variant updates, and customer operations
- **AirtableClient** (`shared/airtable_client.py`): Handles Airtable API interactions with pagination support

### Dynamic Configuration System
Collections with automation jobs are identified by:
1. **Collection Naming**: Collections start with "Auto -" prefix for efficient discovery
2. **Metafield Configuration**: Each collection has a `custom.job_settings` metafield containing:
   ```json
   {
     "jobType": "getTopResellProducts",
     "Description": "Based Airtable Sales Data of Spain, we automatically update this collection for resell products",
     "AIRTABLE_BASE_ID": "appDE0y01TchMqX8N",
     "AIRTABLE_TABLE_ID": "tbljkyhWy5D6b65Im",
     "AIRTABLE_VIEW_ID": "viwixRrDpjcAYwHId",
     "UPDATE_FREQUENCY_HOURS": "24",
     "MAX_AIRTABLE_RECORDS": "500",
     "MIN_QUARTERLY_SALES": "5",
     "EXCLUDED_TAGS": ["retail"],
     "INCLUDED_TAGS": null,
     "BRAND_KEYWORDS": ["nike", "air jordan", "adidas", "yeezy", "new balance", "asics", "puma", "pop mart"]
   }
   ```

### Data Flow
1. **Discovery**: System scans all collections starting with "Auto -" prefix
2. **Configuration**: Parses `custom.job_settings` metafield for each collection
3. **Validation**: Validates job settings against appropriate Pydantic models
4. **Execution**: Creates appropriate job executor and runs job for each collection
5. **Reporting**: Provides detailed execution results and status for all collections

### Supported Job Types
- **getTopResellProducts**: Fetches Airtable sales data, filters products, and updates collection

### Key Business Rules (getTopResellProducts)
All filtering criteria are now **configurable per collection** via metafields:
- **Brand Keywords**: Configurable list (default: nike, air jordan, adidas, yeezy, new balance, asics, puma, pop mart)
- **Excluded Tags**: Configurable list of tags to exclude (can be null for no exclusions)
- **Included Tags**: Configurable list of required tags (can be null for no requirements)
- **Sales Threshold**: Configurable minimum quarterly sales (default: 5.0)
- **Data Sources**: Collection-specific Airtable base, table, and view IDs

## Configuration

### Environment Variables
Required environment variables (stored in `.env` file):
- `AIRTABLE_TOKEN`: Airtable Personal Access Token
- `SHOPIFY_ADMIN_TOKEN`: Shopify Admin API Token
- `SHOPIFY_SHOP_DOMAIN`: Shopify shop domain (e.g., "yourshop.myshopify.com")

### Dynamic Job Configuration
Each collection's job settings are stored in Shopify metafields:
- **Namespace**: `custom`
- **Key**: `job_settings`
- **Type**: JSON
- **Content**: Job-specific configuration parameters

### Collection Identification
- Collections with automation must start with "Auto -" prefix
- This naming convention enables efficient discovery without scanning all collections

## Field Mapping

Critical Airtable to model field mappings:
- `Product Title` ‚Üí `product_name`
- `Vendor` ‚Üí `brand` 
- `Tags` ‚Üí `tags` (comma-separated string to list)
- `‚àû Shopify Id` ‚Üí `shopify_id` (enables direct product updates)
- `Ventas trimestre` ‚Üí `quarterly_sales`
- `Total sale` ‚Üí `total_sales`

## Performance Optimizations

- **Efficient Collection Discovery**: Filters collections by "Auto -" prefix before checking metafields
- **Pagination**: Both Airtable and Shopify clients handle API pagination automatically
- **Direct ID Updates**: Uses Shopify product IDs from Airtable instead of name-based searches
- **Parallel Processing**: Can process multiple collections concurrently using ThreadPoolExecutor (max 3 concurrent)
- **Fast Collection Updates**: Uses "clear and rebuild" strategy - removes all products then adds new ones in correct order
- **Optimized Batch Sizes**: 50 products per batch for both removal and addition operations
- **Smart Progress Reporting**: Progress updates every 50 products to reduce log noise
- **Error Handling**: Continues processing remaining collections if individual jobs fail

## Extensibility Framework

### Adding New Job Types

To add a new job type (e.g., "seasonalProducts"):

1. **Define Job Type** in `models.py`:
   ```python
   class JobType(str, Enum):
       GET_TOP_RESELL_PRODUCTS = "getTopResellProducts"
       SEASONAL_PRODUCTS = "seasonalProducts"  # New job type
   ```

2. **Create Job Settings Model** in `models.py`:
   ```python
   class SeasonalProductsJobSettings(BaseJobSettings):
       SEASON_START_DATE: str
       SEASON_END_DATE: str
       PRODUCT_CATEGORIES: List[str]
       
       @validator('jobType')
       def validate_job_type(cls, v):
           if v != JobType.SEASONAL_PRODUCTS:
               raise ValueError(f"Invalid job type for SeasonalProductsJobSettings: {v}")
           return v
   ```

3. **Implement Job Executor** in `job_executor.py`:
   ```python
   class SeasonalProductsJobExecutor(JobExecutor):
       def get_supported_job_type(self) -> str:
           return "seasonalProducts"
       
       def execute(self, collection_with_settings: CollectionWithJobSettings) -> Dict[str, Any]:
           # Implement seasonal products logic
           pass
   ```

4. **Register Executor** in `JobExecutorFactory._register_executors()`:
   ```python
   executors = [
       TopResellProductsJobExecutor(self.airtable_token, self.shopify_client),
       SeasonalProductsJobExecutor(self.airtable_token, self.shopify_client),  # Add new executor
   ]
   ```

5. **Update Factory Method** in `CollectionWithJobSettings.create_job_settings_from_dict()`:
   ```python
   if job_type == JobType.SEASONAL_PRODUCTS:
       return SeasonalProductsJobSettings(**job_data)
   ```

### Job Settings Example for New Type
```json
{
  "jobType": "seasonalProducts",
  "Description": "Automatically manage seasonal product collections",
  "SEASON_START_DATE": "2024-12-01",
  "SEASON_END_DATE": "2024-12-31",
  "PRODUCT_CATEGORIES": ["winter", "holiday", "gifts"],
  "UPDATE_FREQUENCY_HOURS": "12",
  "MAX_AIRTABLE_RECORDS": "300"
}
```

## Collection Update Strategy

The system uses a **"clear and rebuild"** approach for collection updates:

1. **Discovery Phase**: Find collections starting with "Auto -" and parse their metafield settings
2. **Data Fetching**: Retrieve sales data from Airtable using collection-specific configurations
3. **Filtering**: Apply dynamic filtering criteria (brands, tags, sales thresholds) from metafields
4. **Validation**: Check for products missing Shopify IDs and report them clearly:
   ```
   ‚ùå Product "Example Product" has no valid Shopify ID (current ID: None), skipping
   ‚ö†Ô∏è  2 products skipped due to missing Shopify IDs:
     1. Example Product
     2. Another Product
   ```
5. **Collection Update**: 
   - Remove ALL existing products from collection
   - Add filtered products in sales-ranked order (highest quarterly sales first)
6. **Parallel Execution**: Process multiple collections concurrently

## Shopify API Integration

- **API Version**: Uses 2025-01 (latest available)
- **Collection Access**: Uses `collection_listings` endpoint instead of direct collections API
- **Batch Operations**: 50 products per batch for optimal performance
- **Rate Limiting**: Built-in delays and retry logic for 429 responses
- **Error Handling**: Continues processing other collections if one fails

# Inventory Synchronization System

## Overview

The inventory sync system automatically synchronizes Shopify product variant inventory quantities to their `custom.inventory` metafields every 2 hours. It features intelligent change detection using local caching to only update variants with inventory changes, optimizing performance and reducing API calls.

## Key Features

### Change Detection Optimization
- **Local JSON Cache**: Stores previous inventory states to detect changes
- **Smart Updates**: Only updates variants with inventory changes
- **Atomic File Operations**: Ensures cache integrity with atomic writes

### Concurrent Processing
- **Per-Product Concurrency**: Variants within each product updated concurrently
- **Sequential Products**: Products processed sequentially to avoid rate limits
- **Configurable Workers**: Limits concurrent requests (max 5 per product)

### Multiple Execution Modes

#### Dynamic Collections
- **Manual Sync**: One-time collection update
- **Scheduled Mode**: Continuous 15-day interval execution (configurable)
- **Dry Run**: Analysis mode showing changes without updating collections

#### Inventory Sync
- **Manual Sync**: One-time synchronization
- **Scheduled Mode**: Continuous 2-hour interval execution
- **Dry Run**: Analysis mode showing changes without making updates

### Comprehensive Monitoring
- **Progress Tracking**: Real-time progress indicators during sync
- **Detailed Logging**: Separate log file (`logs/inventory_sync.log`)
- **Error Isolation**: Individual variant failures don't stop the entire process
- **Statistics Reporting**: Success/failure counts and execution times

## Configuration

### Environment Variables

#### Core Configuration
- `AIRTABLE_TOKEN`: Airtable Personal Access Token
- `SHOPIFY_ADMIN_TOKEN`: Shopify Admin API Token
- `SHOPIFY_SHOP_DOMAIN`: Shopify shop domain (e.g., "yourshop.myshopify.com")

#### Dynamic Collections Scheduling
- `DYNAMIC_COLLECTIONS_INTERVAL_DAYS`: Sync interval (default: 15 days)

#### Inventory Sync Configuration
- `INVENTORY_SYNC_INTERVAL_HOURS`: Sync interval (default: 2 hours)
- `INVENTORY_SYNC_DRY_RUN`: Enable dry-run mode (default: false)

#### Customer Marketing Sync Configuration
- `CUSTOMER_MARKETING_SYNC_INTERVAL_HOURS`: Sync interval (default: 6 hours)
- `CUSTOMER_MARKETING_SYNC_DRY_RUN`: Enable dry-run mode (default: false)

### Local Data Storage
- **Inventory Cache File**: `data/inventory_cache.json`
  - **Structure**: Product/variant inventory history with timestamps
  - **Automatic Cleanup**: Cache updates automatically with each sync
- **Customer Marketing Cache File**: `data/customer_marketing_cache.json`
  - **Structure**: Customer marketing subscription states with timestamps
  - **Automatic Cleanup**: Cache updates automatically with each sync

## Usage

### CLI Integration
```bash
python main.py

# Option 1: üîÑ Dynamic Collections
# Choose execution mode:
#   1. Manual Sync (run once)
#   2. Scheduled Mode (run every 15 days)
#   3. Dry Run (analyze changes only)

# Option 2: üì¶ Inventory Sync  
# Choose execution mode:
#   1. Manual Sync (run once)
#   2. Scheduled Mode (run every 2 hours)
#   3. Dry Run (analyze changes only)

# Option 3: üë• Customer Marketing Sync
# Choose execution mode:
#   1. Manual Sync (run once)
#   2. Scheduled Mode (run every 6 hours)
#   3. Dry Run (analyze changes only)
```

### Direct Execution
```bash
# Dynamic Collections
python scripts/dynamic_collections/main.py --mode manual     # One-time sync
python scripts/dynamic_collections/main.py --mode scheduled  # Every 15 days
python scripts/dynamic_collections/main.py --dry-run         # Analysis only

# Inventory Sync
python scripts/inventory_sync/main.py --mode manual          # One-time sync
python scripts/inventory_sync/main.py --mode scheduled       # Every 2 hours
python scripts/inventory_sync/main.py --dry-run              # Analysis only

# Customer Marketing Sync
python scripts/customer_marketing_sync/main.py --mode manual          # One-time sync
python scripts/customer_marketing_sync/main.py --mode scheduled       # Every 6 hours
python scripts/customer_marketing_sync/main.py --dry-run              # Analysis only
```

## Metafield Configuration

### Inventory Sync Target Metafield
- **Namespace**: `custom`
- **Key**: `inventory`
- **Type**: `single_line_text_field`
- **Value**: Current inventory quantity as string

### Customer Marketing Sync Target Metafield
- **Namespace**: `custom`
- **Key**: `accepts_marketing`
- **Type**: `single_line_text_field`
- **Value**: Customer marketing preference as "true" or "false"

### Example Metafield Values
```json
// Inventory metafield
{
  "namespace": "custom",
  "key": "inventory", 
  "value": "42",
  "type": "single_line_text_field"
}

// Customer marketing metafield
{
  "namespace": "custom",
  "key": "accepts_marketing",
  "value": "true",
  "type": "single_line_text_field"
}
```

## Performance & Optimization

### API Efficiency
- **Change Detection**: Avoids unnecessary API calls
- **Batch Processing**: Handles large inventories efficiently
- **Rate Limiting**: Built-in delays and retry logic
- **Pagination Support**: Handles stores with thousands of products

### Local Caching
- **Change Detection**: Only processes variants with inventory changes
- **Fast Comparison**: JSON-based state comparison
- **Minimal Storage**: Compact cache structure
- **Atomic Updates**: Prevents cache corruption

### Concurrent Processing
- **Product-Level**: Sequential processing to respect rate limits
- **Variant-Level**: Concurrent updates within each product (max 5 workers)
- **Error Isolation**: Failed variants don't affect others

## Error Handling

### Rate Limiting
- **Automatic Retry**: Built-in retry logic for 429 responses
- **Exponential Backoff**: Gradual delay increases
- **Request Spacing**: Small delays between requests

### Failure Recovery
- **Individual Isolation**: Single variant failures don't stop sync
- **Comprehensive Logging**: Detailed error messages with context
- **Graceful Degradation**: Continues processing remaining variants
- **Cache Preservation**: Updates cache even with partial failures

## Troubleshooting

### Common Issues
- **Missing Shopify IDs**: System will clearly list products without valid Shopify IDs
- **Collection Count Mismatch**: Expected when some filtered products lack Shopify IDs
- **API 404 Errors**: Usually indicates missing permissions or incorrect API version
- **No Sales Records**: Check Airtable base/table/view IDs in collection metafields
- **Import Errors**: Install APScheduler with `pip install APScheduler`
- **Permission Errors**: Ensure variant metafield write permissions

### Required Shopify Permissions
- `read_products` and `write_products` (for collections access)
- `read_product_listings` and `write_product_listings` (for collection_listings API)
- `read_metaobjects` and `write_metaobjects` (for metafield access)
- `read_inventory` (for inventory quantity access)
- `write_variants` (for variant metafield updates)
- `read_customers` and `write_customers` (for customer marketing sync and customer metafield updates)

## Logging

Optimized logging system:
- Console output for real-time monitoring during execution  
- File logging to `dynamic_collection.log` for persistence and debugging
- Structured log messages with timestamps, component names, and log levels
- Progress indicators for batch operations (üóëÔ∏è for removal, ‚ûï for addition)
- Clear error reporting with product names for missing Shopify IDs
- Execution summaries with success/failure counts per collection